from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy import and_, or_
from sqlalchemy.ext.declarative import declarative_base
from HoundSploit.searcher.db_manager.session_manager import start_session
from HoundSploit.searcher.db_manager.result_set import queryset2list

Base = declarative_base()


class Exploit(Base):
    __tablename__ = 'searcher_exploit'

    id = Column(Integer, primary_key=True)
    file = Column(String)
    description = Column(String)
    date = Column(String)
    author = Column(String)
    type = Column(String)
    platform = Column(String)
    port = Column(Integer)

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.id == other.id
        else:
            return False

    def __ne__(self, other):
        return not self.__eq__(other)
    

    def __init__(self, id, file, description, date, author, exploit_type, platform, port):
        self.id = id
        self.file = file
        self.description = description
        self.date = date
        self.author = author
        self.type = exploit_type
        self.platform = platform
        self.port = port


    @staticmethod
    def search_exploits(searched_text):
        word_list = str(searched_text).split()
        if str(searched_text).isnumeric():
            return Exploit.search_vulnerabilities_numerical(word_list[0])
        """
        if str(searched_text).isnumeric():
            return search_vulnerabilities_numerical(word_list[0], db_table)
        elif str_is_num_version(str(searched_text)) and str(searched_text).__contains__(' ') and not str(searched_text).__contains__('<'):
            result_set = search_vulnerabilities_version(word_list, db_table)
            # union with standard research
            std_result_set = search_vulnerabilities_for_text_input(searched_text, db_table)
            # union_result_set = join_result_sets(result_set, std_result_set, db_table)
            union_result_set = join_lists(queryset2list(result_set), queryset2list(std_result_set))
            if len(union_result_set) > 0:
                return union_result_set
            else:
                return search_vulnerabilities_for_description(word_list, db_table)
        else:
            result_set = search_vulnerabilities_for_description(word_list, db_table)
            if len(result_set) > 0:
                return result_set
            else:
                result_set = search_vulnerabilities_for_file(word_list, db_table)
                if len(result_set) > 0:
                    return result_set
                else:
                    return search_vulnerabilities_for_author(word_list, db_table)
        """


    @staticmethod
    def search_vulnerabilities_numerical(searched_text):
        session = start_session()
        queryset = session.query(Exploit).filter(or_(Exploit.description.contains(searched_text),
                                                    Exploit.id == int(searched_text),
                                                    Exploit.file.contains(searched_text),
                                                    Exploit.port == int(searched_text)
                                                    ))
        session.close()
        return queryset2list(queryset)
